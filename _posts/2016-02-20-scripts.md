---
layout: post
title: Scripts
---

# find

```bash
$ find -L /path/to/search -type f -iname "*filename*"
```

# Bulk rename

```bash
a=1
for i in *.jpg; do
  new=$(printf "%04d.jpg" "$a") #04 pad to length of 4
  mv -- "$i" "$new"
  let a=a+1
done
```

# Number range

```bash
# -w means equal width
$ seq -w 5 20
```

# netstat

```bash
$ netstat -npatu
```

Try `l` instead of `a`.

# ln

Soft/symbolic link (symlink) points to file's directory entry while hard link points to file's inode. No matter of symlink or hard link, both are real but special files.

   When delete a symlink file, the orginal file is not touched. However, to delete a hard link file, the original file's hard link references count will be decreased by 1. If the final count equal to 0, then the original file is deleted as well.

# Encoding/charset conversion

   Charset is a set of *character* entities while encoding is its representation in the terms of *bytes* and *bits*.  In Enca, the word encoding means the same as *representation of text*, i.e. the relation between sequence of character entities constituting the text and sequence of bytes (bits) constituting the file.
   
   ```bash
   $ enca/file filename, detect encoding
   $ enconv filename, convert to *locale*
   $ enconv/enca -x gb2312 filename, convert to specified encoding
   ```

   1. *enca/enconv* is a tool superior to *iconv*.
   2. It does NOT make backup.

# CR-LF/LF

1. CR: Carriage Return, '\r', '\o015', '\xd'.
2. LF: Line Feeding, '\n', '\o12', '\xa'.
3. Some DOS files are ended with CR-LF, while others are LF-CR.

## Detect line ending:

```bash
$ hexdump -c input.file, detect line ending
$ sed -n l input.file
$ file input.file
```

## Conversion

*app-text/dos2unix*:

```bash
$ dos2unix/unix2dos -b input.file, '-b' makes a backup
```

*perl*:

```bash
$ perl -pi -e 's/\r//g' input.file
$ perl -pi -e 's/\n/\r\n/g' input.file
```

*sed*:

```bash
$ sed -i 's/\r//' input.file
$ sed -i 's/$/\r/' input.file
```

*tr*:

```bash
$ tr -d '\r' < input.file > output.file, cannot do it the other way round
```

*nano*:

>Type Ctrl-O and before confirming, type Alt-D (DOS) or Alt-M (Mac) to change the format.

Refer to [remove CRs from CR-LF line terminators](http://mywiki.wooledge.org/BashFAQ/052).

# Trim whitespaces

*echo*:

```bash
# `echo' without double quotes; squeeze sequencial spaces within the string to single one
str="   how   are	you   "
echo -e "$str"
echo -e $str
str=`echo $str`
```

*sed*:

```bash
$ str=" how    are    you   "
$ echo "$str" | sed 's/^[ \t]*//'
$ echo "$str" | sed 's/^[ \t]*//'
$ sed 's/^[ \t]*//;s/[ \t]*$//' <<< "$str"
```

*awk/gawk*:

```bash
# even sequencial tabs (maybe other blank characters) are squeezed to single space within string
$ awk '{$1=$1};1' file
```

# xspf2m3u

```
#!/bin/bash

input=~/Downloads/2016.11.11-vlc.xspf.xml

echo "#EXTM3U" > iptv.m3u

while IFS= read -r location
do
    if [[ $location = *"<location>"*"</location>"* ]] && [[ $location != *gslb* ]] ;
    then
	location=`echo $location | cut -d '>' -f 2 | cut -d '<' -f 1`
	read -r title
	title=`echo $title | cut -d '>' -f 2 | cut -d '<' -f 1`
	echo "#EXTINF:-1,$title" >> iptv.m3u && echo "$location" >> iptv.m3u
    fi
done < "$input"
```

# genm3u

```bash
#!/bin/bash

input=~/Downloads/海外自用高清节目源31套（凤凰台、澳亚、亚太、星空卫视、中天、HKTV等）.txt

echo "#EXTM3U" > tmp.m3u 

IFS=$','
while read -r title url
do
    title=`awk '{$1=$1};1' <<< "$title"`
    title=`cut -d $' ' -f 2 <<< "$title"`
    echo "#EXTINF:-1,$title" >> tmp.m3u && echo "$url" >> tmp.m3u
done < "$input"
```
