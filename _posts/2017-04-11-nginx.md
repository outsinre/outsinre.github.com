---
layout: post
title: Nginx
---

1. toc
{:toc}

# Nginx Installation #

```bash
~ # dnf install nginx
~ # systemctl enable nginx
~ # systemctl status nginx
```

# Nginx Overview #

1. [Starter](https://nginx.org/en/docs/beginners_guide.html)
2. Nginx has one master process and several worker processes.
   1. The main purpose of master process is to read and evaluate configurations, maintain worker processes, manage TCP connections etc.
   2. Worker processes serve client requests. The number of worker processes can be configured and is subject to system resources like number of CPU cores, storage size of HDDs, load pattern etc.
3. Nginx employs event-based model and OS-dependent mechanisms to efficiently distribute requests among worker processes.

# Have a Try #

Test configuration:

```bash
~ # nginx -t
```

Start Nginx:

```bash
~ # nginx -p </path/to/prefix>
```

We can control Nginx with the `nginx -s <signal>` option:

1. reload - reloading Nginx configuration
2. reopen - log file rotation
3. quit - gracefully shutdown Nginx. Stop only all current requests are served.
4. stop - fast shutdown.

We can also [control](https://nginx.org/en/docs/control.html) Nginx by sending *signal* to the master process directly. For example, `kill -HUP <master-pid>` is an equivalent of `nginx -s reload`. By the way, `systemctl reload nginx` is just a wrapper of `nginx -s reload`.

# Nginx Context #

A Simple Directive consists of a *name* and parameters separated by spaces and ends with a semicolon (`;`).

>name arg1 arg2 ... argN ;

A Block Directive has the same structure as a simple directive. But the ending semicolon is substituted with a set of additional Instructions (not necessarily Directives) surrounded by braces (`{` and `}`), like [map](https://nginx.org/en/docs/http/ngx_http_map_module.html).

>name arg1 arg2 ... argN { instructions }

If a Block Directive can have other Directives inside the braces, it is called a Context, like _events_, _http_, _server_, and _location_. The _location_ context is what we mainly work with.

Contexts can be nested. For example, the _events_ and _http_ directives reside in the _main_ context, _server_ in _http_ and _location_ in _server_.

The _main_ context is a special context. It is the parent context of everything in the configuration - the outmost context. Directives outside of any contexts are considered to be in the _main_ context. However, Nginx does not name it explicitly.

Here is a sample skeleton of configuration Context:

```
# main context

directive1;

events {
    directive2;
    directive3;
}

http {
    directive4;

    map $http_upgrade $connection_header {
        default upgrade;
        '' close;
    }

    server {
        directive5;

        location [ = | ~ | ~* | ^~ ] uri {
            directive6;
            directive7;
        }
        
        directive8;
    }

    directive9;
}
```

# Configuration Tips #

Do not Repeat Yourself.

1. Set directives at their broadest applicable context.
2. Modular configuration. Different configuration files or directories can be integrated into _nginx.conf_ by the _include_ directive.

   Here is the common list of configuration modules.

   1. sites-available
   2. sites-enabled - symbolic links to sites-available
   3. default.d
   4. modules.d
   5. conf.d
   6. stream.d

# Server Context Match #

Nginx determines which server context should serve a request.

1. It tests the IP and port of _listen_ directives of server contexts.

   If a listen directive matches *dst.ip* and/or *dst.port*, then the server context is selected as a candidate.
2. For each selected candidate, Nginx tests the `$host` variable against the `server_name` directive. At most, only one candidate can be matched.
   1. If there is one matched, that candidate is selected to serve the request.
   2. If none of the candidates is matched, then choose the *default server* context.

   Check whatever regarding how *default server* is explicitly or implicitly defined. Explicitly, we can append `default_server` instruction to a _listen_ direcitve, but it is a property of the *port* part of the _listen_ directive, not the *ip* part.

# Location Conext Match #

Once a server context is determined, a location context should be selected. Nginx tests the *request line* `request_uri` without query arguments, namely the [uri](https://stackoverflow.com/a/48709976) part (i.e. `document_uri`).

A general _location_ context is defined as `location optional_modifier uri { }`. The *optional_modifier* can be one of `= | ~ | ~* | ^~`.

1. `=` means *exact* match.
2. `~` (case-sensitive) and `~*` (case-insensitive) do *regex* match.
3. If none of the modifiers are provided, do *prefix* match.
   1. `^~` is a special modifier to *prefix* match. If the relevant `uri` has the *longest prefix*, Nginx omits the *regex* match. Hence, we call it *not regex* match.

The match (search) order is as follows:

1. Firstly, do *exact* match `=`. If matched, terminate the search.
2. Secondly, do *prefix* match. Nginx searches the *longest prefix* of `uri`, irrespective of location context order in the configuration file.

   If there is not any location contexts defined, Nginx assumes the default prefix `/index.html`. So, we always can get a longest prefix match.

   1. If the longest match has modifier `^~`, then terminate the search.
   2. Otherwise, the longest match is kept as a candidate.
3. Thirdly, do *regex* match in the order of their appearance in the configuration file.
   1. The first match terminates the search.
   2. If none of the regex is matched, then the longest prefix match in 2.2 is selected.

# if else #

Nginx *if* does not support logical AND or OR. To achieve logical OR, add a separate *if* directive. For logical AND, we can set a variable and then concatenate multiple values together as below.

```
if ($request_uri = /) {
  set $con root;
}

if ($host ~* example.com) {
  set $con "${con}+example.com";
}

if ($http_cookie !~* "auth_token") {
  set $con "${con}+no_auth_token";
}

if ($con = "root+example.com+no_auth_token") {
  return 403;
}
```

# Number of Connections #

By default, a single worker process allows 1024 connections simutaneously. We can litmit the number by:

```
events {
    worker_connections 50;
}
```

# Catch-all Virtual Server #

```
# catch-all 'default_server' vhosts

server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
    root /usr/share/nginx/html;

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;

    location / {
	    # Use "$host" instead of "$server_name" unless you have special needs.
        #return 301 https://$server_name$request_uri;
        return 301 https://$host$request_uri;
    }
}

# Settings for a TLS enabled server.

server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;

    server_name _;
    root /usr/share/nginx/html;

    # Let's Encrypt will start offer wildcard certs beginning 2018
    ssl_certificate "/etc/letsencrypt/live/example.com/fullchain.pem";
    ssl_certificate_key "/etc/letsencrypt/live/example.com/privkey.pem";
    ssl_session_cache shared:SSL:1m;
    ssl_session_timeout  10m;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;

    location / {
        return 404;
    }

    error_page 404 /40x.html;
    location = /40x.html {
        internal;
    }

    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        internal;
    }

}
```

1. All HTTP requests are redirected (301) to HTTPS.
2. Trigger 404 code, telling end users that the request is not expected.
3. Attention to `server_name: _;`. It is not a must.
