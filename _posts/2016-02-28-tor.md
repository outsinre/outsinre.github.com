---
layout: post
title: Tor - Anonymity Online
---

> All ip[6]tables commands now should be converted into */var/lib/ip[6]tables/rules-save* and use *ip[6]tables-apply* instead. Refer to post *iptables*.

# ABCs

1. Tor - the onion router - mainly devotes to hide your Internet identity.
2. Tor prevents people from learning your location or browsing habits.
3. Tor is for web browsers, instant messaging clients, and more.
4. Tor aims at outbound traffic.

# How

1. Tor perodically chooes different encryption routing relays. Your Tor IP is the exit relay's IP.

   Tor relay/node is usually free and built to route Tor traffic.
2. Tor traffic is NOT encrypted between *exit relay* and destination host.
3. Tor needs a centralized *directory host* to receve a list of *relay* relays.
4. Tor is blocked by GFW:
   1. Block the *directory* host;
   2. Block the *handshake* process;
   3. Block intermediate relys.
   4. Malicious relays.

   The 1st item is key cause. There are two methods to solve the issue:

   1. Front end proxy;
   2. Tor Bridge
5. Add a frontend proxy (Lantern for instance) to Tor. Frontend proxy bypasses GFW while Tor hide your Internet track.

   In this post, I use *ss* (also a SOCKS5) as the frontend proxy.
6. On startup, Tor access a public replay directory to get a list of relays. By specifing *private* Bridges in configuration file, Tor receive replays from the specified Bridges.
7. *Do NOT enable Front end proxy and Bridges simutaneously*, otherwise Tor did not work!

   Mostly, I use Frontend proxy: mutliple proxies more secure.
7. Use Tor not only to surf the Internet, but for other applications that support SOCKS5.

# Installation

```bash
# echo "net-misc/tor transparent-proxy
# emerge net-misc/tor
# rc-service tor start
# rc-update add tor default
```

# Configuration - */etc/tor/torrc*

Refer to */etc/tor/torrc.sample* and `man tor`.

1. Basics

   ```
   User tor
   PIDFile /var/run/tor/tor.pid
   Log notice syslog
   DataDirectory /var/lib/tor/data
   AvoidDiskWrites 1
   DirReqStatistics 0
   ```

2. Frontend proxy

   Tor is blocked by GFW. We add a frontend proxy to Tor bypassing GFW. This proxy server will be inserted between *localhost* and Tor *entry relay*.

   This post uses *ss* - a SOCKS5 proxy.

   ```
   Socks5Proxy 127.0.0.1:1080
   ```

   Application -> Tor -> frontend proxy -> entry relay -> intermediate rely -> exit relay -> destination host. Traffic between application and exit relay is encrypted. Localhost IP is plain between application and frontend proxy.

   Though frontend proxy knows your IP but the traffic is encrypted! Exit relays and destination host know your traffic but does not know your real IP. What's more, if you visit destination host by *https*, then exit relay only knows encrypted *https* traffic.

   Bingo!
2. Bridges

   Bridges need *obfsproxy* support.

   ```bash
   # emerge -avt obfsproxy
   ```

   [get bridges](https://bridges.torproject.org/) tells how to obtain bridge address (usually 3 is enough).

   ```
   UseBridges 1
   Bridge obfs3 ip1:port1 fgp1
   Bridge obfs3 ip2:port2 fgp2
   Bridge obfs3 ip3:port3 fpg3
   ClientTransportPlugin obfs3 exec /usr/bin/obfsproxy managed
   ```

   Restart Tor service!
3. Stream isolation

   Isolate different applications by Tor port. By default, Tor service listens on *9050* port for all traffic. We can open more Tor ports for different applications.

   For example, web browser and instant messanger should better connect to Tor ports.

   ```
   # web browser
   SocksPort 127.0.0.1:9050
   # gpg client
   SocksPort 127.0.0.1:9100
   # instant messenger
   SocksPort 127.0.0.1:9150
   ```

4. ExcludeNodes

   Tor relies on routing *relay*. There are also malicious relays set by attacker/countries to analyze Tor traffic.

   Tell Tor not to use those relays:

   ```
   ExcludeNodes {cn},{hk},{mo}
   strictnodes 1
   ```

   Others are `kp ir sy pk cu vn`.
5. TorDNS

   Though *Tor + frontend proxy* is secure enough to hide your surfing track, DNS server still knows where you connect. So we further hide the DNS resolving process.

   *ATTENTION*: even you choose not to use Tor surfing the Internet, you can always use TorDNS resolver. That is why I add *tor* to default run level.

   1. To use TorDNS resolver:

      ```
      DNSPort 9053
      DNSListenAddress 127.0.0.1
      VirtualAddrNetworkIPv4 10.192.0.0/10
      AutomapHostsOnResolve 1
      AutomapHostsSuffixes .exit,.onion
      ```

      The 3rd line `VirtualAddrNetworkIPv4 10.192.0.0/10` is very important! Otherwise, some applications cannot resolve (TorDNS) or connect to (Transparent proxy discussed below) `.onion .exit` address.
   2. Set TorDNS sever

      ```
      # /etc/resolv.conf
      nameserver 127.0.0.1
      ```

   3. Redirect DNS request to Tor port 9053.

       Redirect ALL DNS request on system from port 53 to 127.0.0.1:9053 where TorDNS listen for requests. Redirected to the local (torified) nameserver any DNS connection left.

      ```bash
      # iptables -t nat -A OUTPUT -p TCP --dport 53 -j DNAT --to-destination 127.0.0.1:9053
      # iptables -t nat -A OUTPUT -p UDP --dport 53 -j DNAT --to-destination 127.0.0.1:9053
      ```

   4. Disable Dhcpcd's *resolve.conf* hook, otherwise it will override */etc/resolv.conf* file on startup.

      ```
      # /etc/dhcpcd.conf
      nohook resolv.conf
      ```
      
      Another obvious method is to remove */lib/dhcpcd/dhcpcd-hooks/20-resolv.conf* file.
   5. *tor-resolve* - TorDNS's command line tool.

      ```bash
      $ tor-resolve www.baidu.com
      ```
   6. Now all DNS request on system will use TorDNS.

      Try `ping www.google.com` which is impossible without *proxychain* + *ss*.

6. torify / torsocks - command line tool

   *torify* will allow application traffic flows via the Tor network without the need to make configuration changes to the application involved. Force traffic through Tor on demand in terminal, i.e. `$ usewithtor emacs` or change script of *ect ecx emacs.desktop emacsclient.desktop* to torify Emacs.

   Application like Firefox configures their proxy settings to use Tor proxy. But it's annoying to configure each application to use Tor. What's worse, some application even does NOT allow proxy like Bitorrent, wget, apt-get, gpg, etc.

   This is where torify plays a role: *force* applications ot use proxy. Applications utilize Tor wihtout notice.

   ```bash
   # emerge -av net-proxy/torsocks

   $ torify wget -qO- https://check.torproject.org/ | grep -i congratulations
   $ wget -qO- https://check.torproject.org/ | grep -i congratulations
   ```

   It calls *torsocks* with a tor specific configuration file (*/etc/torsocks.conf*). Compare the output between *torify* and without *torify*.

   Refer to [torify howto](https://trac.torproject.org/projects/tor/wiki/doc/TorifyHOWTO) and  [torsocks](https://trac.torproject.org/projects/tor/wiki/doc/torsocks).
7. torsocks - more

   In previous step, *torify* make use of *torsocks* to force application traffic through Tor SOCKS5. *torify* calls *torsocks* with the default configuration file */etc/torsocks.conf* in which the default port is 9050 - Tor's default SocksPort! There are other arguments like server address, socks type etc.

   Additionally, *torsocks* can do far more than serving *torify*. For example I can change port and socks version to use other socks proxy. To use torsocks directly, just replace *torify* with `usewithtor`.

   `$ usewithtor wget -qO- https://check.torproject.org/ | grep -i congratulations`.

8. Transparent proxy

   *configuration might be DEPCRECATED, please refer to lastest config file*.

   Though *torify* and *torsocks* force traffic through Tor netowrk without bothering configurating applications, they can only executed on command line. With transparent proxy setting, all non-Tor owned traffic will be redirected to Tor's *TransPort* with command line interfence or application configuration.

   Tor alone cannot achieve transparent proxy without support from Linux kernel's *netfilter* functionality which is the core of Link firewall - Iptables.

   *SocksPort* and *DNSPort* are Tor owned traffic. The former is Tor's TCP traffic while the later is a special case - UDP traffic. Now Iptables will redirect all non-Tor traffic to *TransPort*.

   Once in place, applications do not need to be configured to use Tor, though Tor's *SocksPort* will still work. This also works for DNS via Tor's *DNSPort*, but realize that Tor only supports TCP, thus UDP packets other than DNS cannot be sent through Tor and therefore must be blocked entirely to prevent leaks. Using iptables to transparently torify a system affords comparatively strong leak protection.

   1. Enable Tor's transparent proxy functionality.

      ```
      TransPort 9040
      TransListenAddress 127.0.0.1
      ```

   2. Enable `NETFILTER_ADVANCED` and `XT_MATCH_OWNER` kernel option first.

      ```
      advanced netfiler configuration netfilter_advanced
	 <*>   "owner" match support xt_match_owner
      ```

      Without these two kernel support, iptables won't recognize `-m owner` match.
   3. Redirect non-Tor traffic to transparent proxy

      ```bash
      # iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner tor -j DNAT --to-destination 127.0.0.1:9040
      # rc-service iptables save
      ```

      After the setting, all traffic is owned by Tor.
   4. Pay attention to:
      1. `-p tcp` must accompany `--dport` since only TCP layer has a port number.
      2. `-p tcp` actually implied implicit arguments `-m tcp` which is followed by `--dport`.
   5. Turn off Foxyproxy of Firefox, since no longer needed!
   6. **coarse-grained**: all non-Tor traffic goes through Tor now.

      A fine-grained setting is turn on transparent proxy, use user-defined chain to control in detail which concrete outgoing traffic uses transparent proxy on demand. More on transparent proxy, refer to post *iptables*.
10. Disable non-Tor traffic - an alternative.
    
    Another extreme way is to disable non-Tor traffic completely.

    ```bash
    # iptables -P OUTPUT DROP
    # iptables -A OUTPUT -i lo -j ACCEPT
    # iptables -A OUTPUT -m owner --uid-owner tor -j ACCEPT
    # iptables -P INPUT DROP
    # iptables -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    # iptables -I INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT
    ```

   4. Choose one of the three shceme on security requirement. In daily usage, *torify* and/or *torsocks* suffices.
11. Restart Tor service

   ```
   # rc-service tor restart
   ```

# Firefox setting

1. The main usage of Tor resides in *WWW surfing*. First make sure *foxproxy* extension is installed.

   I have configured *foxproxy* for *ss* previously.
2. In *foxproxy*, *Add New Proxy*.

   ```
   Proxy Name: tor-ss
     Perform remote DNS lookups on hostnames ...

   Host or IP Address: 127.0.0.1 Port: 9050
   SOCKS proxy SOCKS v5
   ```

   1. Remember to place the Tor proxy at the beggining of proxy list - highest proxy priority!
   2. Now Firefox has two proxies to choose from.
   3. Tick *Perform remote DNS lookups ...*
3. about:config

   ```
   network.proxy.socks_remote_dns    true
   network.dns.disablePrefetch       true
   network.dns.disableIPv6           true
   ```

   This way Firefox will resolve host names via Tor proxy DNS resolver (i.e. *ss* also support DNS resolving. Talked laster), which prevents DNS leaks.

   The first item is the key to use TorDNS.

# Usage

## Prerequisite

1. As we add a frontend proxy to Tor, it should launch before Tor working.
2. All DNS lookups on system are through Tor. If application failed to resolve hostnames, check if Tor is running.
   
## Applications.

Any applications that support SOCKS5 proxy can make use of Tor service.

In its proxy setting, fill *socks5* server to *127.0.0.1* and *port* to one of the *stream isolation* port number.

For those do NOT support proxy or Tor, refer to *transparent proxy* above.
## Firefox

Up to now, Firefox has two SOCKS5 proxy servers Tor and *ss* to choose from. You can choose either one or both simultaneously through *foxproxy* extension.

1. *ss* for all URLs

   Use *ss* proxy surfing the Internet.
2. Tor alone

   Use Tor surfing the Internet. However, Tor is blocked by GFW making this method infeasible.
3. Simutaneously

   That's how Tor is commonly used: support from frontend proxy. Recall that we add *SocksProxy* in Tor's configuration to enable *ss* frontend proxy.

   When choosing *tor for all URLs* in *foxproxy*, Firefox actually use Tor + *ss* concurrently.
4. Of course, we can choose *use proxies based on their pre-defined patterns and priorities* in *foxproxy*.

## DNS resolving

As discussed above, the system is configured to use TorDNS resolver preventing DNS lookup leaks. All DNS requests are *redirecting* to TorDNS by *iptables*.

Try to `rc-service tor stop`, then the system cannot resolve DNS anymore as TorDNS is down!

# Tips

1. Don't use Tor to sign in Email/forum. The purpose of Tor is hiding traffic tack. Email, forum etc systems can analyze your traffic. No matter which method you use for connection, final interaction with sign in system is plain text.
2. 关于深网

   深网用户通过特殊的技术手段隐匿用户信息（如IP地址等）登陆“深网”以后，就能完全脱离世间法律或NSA（美国国家安全局）等政府管制力量的钳制和监管，在那里，你可以通过网站肆意的购买枪支弹药，可以发布悬赏杀人的告示，可以购买冰毒和可卡因，可以随意浏览儿童色情网站，也可以办理各种假证伪造身份。仅有4%的网络数据是可以通过搜索引擎找到的，其他的都深藏在“深网”中。

   96%的网络数据都是无法用使用搜索引擎查找的，但这些网站的服务器实体可能分布在互联网管制薄弱的东欧国家，背后由深谙网络安全技术的黑客维护，多以.onion作为域名，采用特殊的加密机制，不能通过搜索引擎查找，即使知道域名也无法采用传统的HTTP方式直接访问，必须采用特殊手段才能接入，就好像只有游吟诗人维吉尔的引领，但丁才可以窥见Limbo里的曲径通幽处。

   而今天我们这个引路人就是Tor（The Onion Router），直译过来为“洋葱路由”。既然已经通过 Tor 打开了“深网”的大门，那么让我们就将其一窥究竟，因为广大的深网网站都无法被搜索引擎收录，所以我们必须要找到一个收录各类深网网站的索引站点，“Hidden Wiki”就是其中较为出名的一个，它收录了各类深网网站地址。
3. Hidden wiki:
   1. http://zqktlwi4fecvo6ri.onion/wiki/
   2. http://torlinkbgs6aabns.onion/
   3. http://wikitjerrta4qgz4.onion/
   4. http://jh32yv5zgayyyts3.onion/

# Refs

1. [gentoo wiki](https://wiki.gentoo.org/wiki/Tor)
2. [gentoo-en](http://gentoo-en.vfose.ru/wiki/Tor)
3. [arch wiki](https://wiki.archlinux.org/index.php/Tor)
4. [cn link1](http://www.gonewto.com/?post/zm2bw2)
5. [cn link2](https://roxhaiy.wordpress.com/2015/01/11/设置shadowsockstor多重代理/)
