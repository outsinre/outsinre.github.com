---
layout: post
title: GDB and gef
---

This is a GDB tutorial to dynamically analyze and exploit programs.

1. toc
{:toc}

# Limitations #

1. GDB currently does not support Apple Arm (M1).

# Extension gef #

[gef](https://github.com/hugsy/gef) is a Python plugin for vanilla GDB, supporting both x86 (32/64) and Arm (AArch 32/64). It is as actively maintained as its successor [pwndbg](https://github.com/pwndbg/pwndbg), comes with just a single Python script file and requires no dependencies except Python. Howeveer, some gef commands [depends](https://hugsy.github.io/gef/install/) on a few other tools like *file*, *readelf*, *nm*, and *ps*.

There are other alternatives like pwndbg and [peda](https://github.com/longld/peda). pwndbg is actively maintained as gef, but the installation script introduces customizations, and spreads files everywhere. The script might introduce conflicts things conflicting with my local setup (e.g. *bashrc*). I quite do not like this style. peda, on the other hand, is almost deprecated, and the last commit is from 4 years ago.

In this post, we elect gef!

Download gef.

```bash
ubuntu@ip-172-31-9-194:~/workspace/ git clone https://github.com/hugsy/gef

ubuntu@ip-172-31-9-194:~/workspace$ cd gef/
ubuntu@ip-172-31-9-194:~/workspace/gef$ ls
LICENSE  README.md  docs  gef.py  mkdocs.yml  scripts  tests
```

Load gef on the fly.

```bash
ubuntu@ip-172-31-9-194:~/misc$ gdb -q
(gdb) source ~/.gdbinit
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
gef➤  arch list
Available architectures:
 Architecture(ARM, ARM, LITTLE_ENDIAN)
  ARM
 Architecture(ARM64, None, LITTLE_ENDIAN)
  ARM64
  AARCH64
 Architecture(MIPS, MIPS64, LITTLE_ENDIAN)
  MIPS64
 Architecture(MIPS, MIPS32, LITTLE_ENDIAN)
  MIPS
 Architecture(PPC, PPC64, LITTLE_ENDIAN)
  PowerPC64
  PPC64
 Architecture(PPC, PPC32, LITTLE_ENDIAN)
  PowerPC
  PPC
 Architecture(RISCV, RISCV, LITTLE_ENDIAN)
  RISCV
 Architecture(SPARC, V9, LITTLE_ENDIAN)
  SPARC64
 Architecture(SPARC, None, LITTLE_ENDIAN)
  SPARC
 Architecture(X86, 64, LITTLE_ENDIAN)
  X86_64
  i386:x86-64
 Architecture(X86, 32, LITTLE_ENDIAN)
  X86
```

Alternatively, enable gef plugin automatically. With the option `--nx`, you can disable gef auto-loading.

```bash
ubuntu@ip-172-31-9-194:~/misc$ echo 'source /path/to/gef.py' >> ~/.gdbinit

ubuntu@ip-172-31-9-194:~/misc$ gdb -q
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
gef➤

ubuntu@ip-172-31-9-194:~/misc$ gdb -q --nx
(gdb)
```

# Introduction #

gdb is a shell command capable of inspecting execution details of a process at a certain point.

Launch a process. With the option `-q, --quiet, --silent`, skip printing the copyright mesage; the option `--se` is optional.

```bash
~ $ gdb -q
(gdb) file /path/to/program

# -or-

~ $ gdb -q [--se] /path/to/program
```

Debug a [core dump](https://gist.github.com/outsinre/d2b58b289425fbdd2d0f0294f3fdf0c9) (from crashed or *gcore*). With the option `-c`, you can omit the binary.

```bash
# binary available
~ $ gdb /path/to/program core.xyz

# no binary; must have '-c'
~ $ gdb -c core.xyz
```

Attach to an existing process. With the option `-p`, you can omit the binary.

```bash
# with binary
~ $ gdb /path/to/program pid

# no binary; must have '-p'
~ $ gdb -p pid
```

Once started, gbd presents you an interactive shell and waits for [gdb commands](#common-commands).

# Debugging Information #

When compiling a executable, we can add the options `-g` and `-Og` to `gcc`, [including debugging information](https://stackoverflow.com/q/89603).

```bash
ubuntu@ip-172-31-9-194:~/misc$ cat test.c
#include <stdio.h>

int main()
{
        printf("%d\n", 100/0);
}

# '-g' includes debug info
# '-Og' optimize debug experience
ubuntu@ip-172-31-9-194:~/misc$ gcc -Wall -Wextra -Og -g -std=c11 -o test.out test.c

ubuntu@ip-172-31-9-194:~/misc$ file test.out
test.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=06b7264bd3f05cfc7ea928d4cc9b257a4c83c8cd, for GNU/Linux 3.2.0, with debug_info, not stripped
```

# Common Commands #

Here is a list of commonly used debugging commands. If you want to repeat the last command, just press ENTER key.

![gdb-common-commands.png](/assets/gdb-common-commands.png)

Like Bash, gdb records commands in `~/.gdb_history`.

The following is an example of the *run* command.

![assets/gdb-example.png](/assets/gdb-example.png)

A program either runs successfully, or runs into issues. For debugging issues, we usually needs the *break* command to let the program pause at a point.

When the program is running in the middle, we can stop it via the following methods.

1. Use shortcut `Ctrl-C` or gdb command `signal SIGINT`.
2. Set a new breakpoint and issue *run* again to start over.

