---
layout: post
title: GDB and gef
---

This is a GDB (GNU DeBugger) tutorial to dynamically analyze and exploit programs.

1. toc
{:toc}

# Limitations #

1. GDB currently does not support Apple Arm (M1).

# Extension gef #

[gef](https://github.com/hugsy/gef) (GDB Ehanced Features) is a Python plugin for vanilla GDB, supporting both x86 (32/64) and Arm (AArch 32/64). It is as actively maintained as its successor [pwndbg](https://github.com/pwndbg/pwndbg), comes with just a single Python script file and requires no dependencies except Python. Howeveer, some gef commands [depends](https://hugsy.github.io/gef/install/) on a few other tools like *file*, *readelf*, *nm*, and *ps*.

There are other alternatives like pwndbg and [peda](https://github.com/longld/peda). pwndbg is actively maintained as gef, but the installation script introduces customizations, and spreads files everywhere. The script might introduce conflicts things conflicting with my local setup (e.g. *bashrc*). I quite do not like this style. peda, on the other hand, is almost deprecated, and the last commit is from 4 years ago.

In this post, we elect gef!

Download gef.

```bash
ubuntu@ip-172-31-9-194:~/workspace/ git clone https://github.com/hugsy/gef

ubuntu@ip-172-31-9-194:~/workspace$ cd gef/
ubuntu@ip-172-31-9-194:~/workspace/gef$ ls
LICENSE  README.md  docs  gef.py  mkdocs.yml  scripts  tests
```

Load gef on the fly.

```bash
ubuntu@ip-172-31-9-194:~/misc$ gdb -q
(gdb) source ~/.config/gdb/gdbinit
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
gef➤  arch list
Available architectures:
 Architecture(ARM, ARM, LITTLE_ENDIAN)
  ARM
 Architecture(ARM64, None, LITTLE_ENDIAN)
  ARM64
  AARCH64
 Architecture(MIPS, MIPS64, LITTLE_ENDIAN)
  MIPS64
 Architecture(MIPS, MIPS32, LITTLE_ENDIAN)
  MIPS
 Architecture(PPC, PPC64, LITTLE_ENDIAN)
  PowerPC64
  PPC64
 Architecture(PPC, PPC32, LITTLE_ENDIAN)
  PowerPC
  PPC
 Architecture(RISCV, RISCV, LITTLE_ENDIAN)
  RISCV
 Architecture(SPARC, V9, LITTLE_ENDIAN)
  SPARC64
 Architecture(SPARC, None, LITTLE_ENDIAN)
  SPARC
 Architecture(X86, 64, LITTLE_ENDIAN)
  X86_64
  i386:x86-64
 Architecture(X86, 32, LITTLE_ENDIAN)
  X86
```

Alternatively, load gef automatically.

```bash
ubuntu@ip-172-31-9-194:~/misc$ echo 'source /path/to/gef.py' >> ~/.config/gdb/gdbinit

ubuntu@ip-172-31-9-194:~/misc$ gdb -q
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
gef➤
```

In addition to standard GDB commands, gef offers enhanced commands. See <https://hugsy.github.io/gef/commands/aliases/>.

# Configuration #

1. *~/.config/gdb/gdbearlyinit* which is checked before any other configuration file.

   ```
   # similar to option '-q'
   set startup-quietly on
   ```

2. *~/.config/gdb/gdbinit* which is the primary configuration file.

   ```
   # load gef automatically
   source /path/to/gef.py'
   ```

# Introduction #

gdb is an interactive Shell capable of inspecting execution details of a process at a certain point, like dereferencing an uninitialized or NULL pointer (address `0x0`).

With the option `--nx`, gdb skips any commands in the [configuration](#configuration).

```bash
~ $ gdb --nx
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb)
```

Launch a process. With the option `--args`, you can specify the arguments immediately following the executable.

```bash
~ $ gdb
(gdb) file /path/to/program
(gdb) run [arglist]

# -or-

~ $ gdb [--args] /path/to/program [arglist]
```

Debug a [core dump](https://gist.github.com/outsinre/d2b58b289425fbdd2d0f0294f3fdf0c9) (from crashed or *gcore*). With the option `-c`, you can omit the binary.

```bash
# binary available
~ $ gdb /path/to/program core.xyz

# no binary; must have '-c'
~ $ gdb -c core.xyz
```

Attach to an existing process. With the option `-p`, you can omit the binary.

```bash
# with binary
~ $ gdb /path/to/program pid

# no binary; must have '-p'
~ $ gdb -p pid
```

# Debugging Information #

When compiling a executable, we can add the options `-g` and `-Og` to `gcc`, [including debugging information](https://stackoverflow.com/q/89603).

```bash
ubuntu@ip-172-31-9-194:~/misc$ cat test.c
#include <stdio.h>

int main()
{
        printf("%d\n", 100/0);
}

# '-g' includes debug info
# '-Og' optimize debug experience
ubuntu@ip-172-31-9-194:~/misc$ gcc -Wall -Wextra -Og -g -std=c11 -o test.out test.c

ubuntu@ip-172-31-9-194:~/misc$ file test.out
test.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=06b7264bd3f05cfc7ea928d4cc9b257a4c83c8cd, for GNU/Linux 3.2.0, with debug_info, not stripped
```

Without debugging information, gdb may fail to show correlated information like symbol translation, backtrace, etc.

The `-Og` makes debugging happy, but the program might be less optimized and performant.

# Common Commands #

Here is a list of commonly used debugging commands.

1. Keyboard ENTER key repeats the last command.
2. *run* starts or restart the program. The argument list can be provided immediately like `run -x y -b`.

   If you are inspecting a core dump, then *backtrace* shows the call stack til the point of failure.
3. *break* pauses the program at the specified line.

   You can define a *contditional* breakpoint like `break 15 if var > 10`.
4 .*watch* monitors a variable and pauses the program when the variable is modified.
5. *c*, *continue* resumes the program until crash, the next breakpoint or exit.
6. *step* steps into funtion call while *next* does not.

   *stepi* steps over machine instruction instead of program statement.
7. *finish* completes the current function call and then pause.
8. *list* shows source code.
9. *info* is very useful, like *info breakpoints*.
10. *print* shows values of variables.
11. *x* shows values referenced by an memory address.
12. *info proc mappings* or *vmmap* shows virtual memory mappings.
13. *record* combined with *reverse-foo* can execute the program in reverse order. Therefore, there is no need to re-run the program to inpsect previous execution contexts.

![gdb-common-commands.png](/assets/gdb-common-commands.png)

The following is an example of the *run* command with the [gef extension](#gef) enabled.

![assets/gdb-example.png](/assets/gdb-example.png)

A program either runs successfully, or runs into issues.

1. When the program is running in the middle, we can stop it via the following methods via shortcut `Ctrl-C` or gdb command `signal SIGINT`.
2. To debugging issues, we usually needs the *break* command to let the program pause at a specific point.

Similar to Bash, you can check historical gdb commands in `~/.gdb_history`.

# hexdump #

hexdump can dump file contents in various formats (e.g. hexadecimal), including customized format with the option `--format`.

The following example dumps the contents in ASCII format.

```bash
~ $ hexdump -C core.xyz | less 

000140b0  f0 b8 1d 00 00 00 00 00  0a 00 00 00 00 00 00 00  |................|
000140c0  00 5f 49 54 4d 5f 64 65  72 65 67 69 73 74 65 72  |._ITM_deregister|
000140d0  54 4d 43 6c 6f 6e 65 54  61 62 6c 65 00 5f 5f 67  |TMCloneTable.__g|
000140e0  6d 6f 6e 5f 73 74 61 72  74 5f 5f 00 5f 49 54 4d  |mon_start__._ITM|
000140f0  5f 72 65 67 69 73 74 65  72 54 4d 43 6c 6f 6e 65  |_registerTMClone|
00014100  54 61 62 6c 65 00 63 72  79 70 74 5f 72 00 6c 75  |Table.crypt_r.lu|
00014110  61 5f 70 75 73 68 66 73  74 72 69 6e 67 00 6c 75  |a_pushfstring.lu|
00014120  61 5f 73 65 74 65 78 64  61 74 61 00 6c 75 61 5f  |a_setexdata.lua_|
00014130  67 65 74 66 69 65 6c 64  00 6c 75 61 4c 5f 70 75  |getfield.luaL_pu|
00014140  73 68 72 65 73 75 6c 74  00 6c 75 61 5f 78 6d 6f  |shresult.lua_xmo|
00014150  76 65 00 6c 75 61 5f 72  65 73 75 6d 65 00 6c 75  |ve.lua_resume.lu|
00014160  61 4c 5f 61 64 64 6c 73  74 72 69 6e 67 00 6c 75  |aL_addlstring.lu|
00014170  61 4c 5f 6f 70 74 6e 75  6d 62 65 72 00 6c 75 61  |aL_optnumber.lua|
00014180  5f 6e 65 77 75 73 65 72  64 61 74 61 00 6c 75 61  |_newuserdata.lua|
00014190  5f 73 65 74 66 69 65 6c  64 00 6c 75 61 5f 73 65  |_setfield.lua_se|
000141a0  74 74 6f 70 00 6c 75 61  5f 70 75 73 68 73 74 72  |ttop.lua_pushstr|
000141b0  69 6e 67 00 6c 75 61 6f  70 65 6e 5f 66 66 69 00  |ing.luaopen_ffi.|
000141c0  6c 75 61 5f 67 65 74 69  6e 66 6f 00 6c 75 61 5f  |lua_getinfo.lua_|
000141d0  69 73 6e 75 6d 62 65 72  00 6c 75 61 4c 5f 63 68  |isnumber.luaL_ch|
000141e0  65 63 6b 6c 73 74 72 69  6e 67 00 6c 75 61 5f 6e  |ecklstring.lua_n|
000141f0  65 78 74 00 6c 75 61 5f  74 6f 74 68 72 65 61 64  |ext.lua_tothread|
00014200  00 6c 75 61 5f 67 63 00  6c 75 61 5f 63 72 65 61  |.lua_gc.lua_crea|
```

However, all the non-printable characters are showed as dots in the ASCII column.

```bash
~ $ for ((i=0; i<=255; ++i)); do printf "\x$(printf %x $i)"; done | hexdump -C
00000000  00 01 02 03 04 05 06 07  08 09 0a 0b 0c 0d 0e 0f  |................|
00000010  10 11 12 13 14 15 16 17  18 19 1a 1b 1c 1d 1e 1f  |................|
00000020  20 21 22 23 24 25 26 27  28 29 2a 2b 2c 2d 2e 2f  | !"#$%&'()*+,-./|
00000030  30 31 32 33 34 35 36 37  38 39 3a 3b 3c 3d 3e 3f  |0123456789:;<=>?|
00000040  40 41 42 43 44 45 46 47  48 49 4a 4b 4c 4d 4e 4f  |@ABCDEFGHIJKLMNO|
00000050  50 51 52 53 54 55 56 57  58 59 5a 5b 5c 5d 5e 5f  |PQRSTUVWXYZ[\]^_|
00000060  60 61 62 63 64 65 66 67  68 69 6a 6b 6c 6d 6e 6f  |`abcdefghijklmno|
00000070  70 71 72 73 74 75 76 77  78 79 7a 7b 7c 7d 7e 7f  |pqrstuvwxyz{|}~.|
00000080  80 81 82 83 84 85 86 87  88 89 8a 8b 8c 8d 8e 8f  |................|
00000090  90 91 92 93 94 95 96 97  98 99 9a 9b 9c 9d 9e 9f  |................|
000000a0  a0 a1 a2 a3 a4 a5 a6 a7  a8 a9 aa ab ac ad ae af  |................|
000000b0  b0 b1 b2 b3 b4 b5 b6 b7  b8 b9 ba bb bc bd be bf  |................|
000000c0  c0 c1 c2 c3 c4 c5 c6 c7  c8 c9 ca cb cc cd ce cf  |................|
000000d0  d0 d1 d2 d3 d4 d5 d6 d7  d8 d9 da db dc dd de df  |................|
000000e0  e0 e1 e2 e3 e4 e5 e6 e7  e8 e9 ea eb ec ed ee ef  |................|
000000f0  f0 f1 f2 f3 f4 f5 f6 f7  f8 f9 fa fb fc fd fe ff  |................|
00000100
```

# strings #

Though [hexdump](#hexdump) shows ASCII characters, it is not easy to retrieve the ASCII part. GNU strings, on the other hand, can dump *printable* characters and helps identify large strings in the core dump.

```bash
~ $ strings -n4 [-tx] /path/to/core.xyz > core.xyz.ascii

~ $ sort -o core.xyz.ascii.sorted core.xyz.ascii

~ $ uniq -c core.xyz.ascii.sorted > core.xyz.ascii.sorted.uniq

~ $ sort -nrk1,1 -o core.xyz.ascii.sorted.uniq.sorted core.xyz.ascii.sorted.uniq
```

However, Non-printable characters are ignored.

# readelf and objdump #

readelf is the [successor](https://stackoverflow.com/a/8979687) of objdump. However, readelf cannot dump source code as objdum does.

Here is an example.

```bash
~ $ objdump --source --source-comment=txt test-gdb.out

...

0000000000001149 <f>:
txt#include <stdio.h>
txt
txtint f(int a, int b)
txt{
    1149:       f3 0f 1e fa             endbr64
txt     int sum;
txt     sum = a + b;
    114d:       8d 04 37                lea    (%rdi,%rsi,1),%eax
txt     return sum;
txt}
    1150:       c3                      ret

...
```

gdb command *disassemble* can also dump source code.

Regarding usage examples of readelf, please refer to biji.
