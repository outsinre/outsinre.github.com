---
layout: post
title: GnuPG 2
---

In the previous post SSH, I talked about *secure connection* (i.e. remote login) on the Internet. Now you will see how GnuPG (GPG) is used to *encrypt/decrypt* messages (i.e. email, documents).

# First run

If you never run *gpg*, then try `--list-keys` or `--fingerprint` (include fingerprint of key).

```bash
jim@laptop ~ $ gpg --list-keys
gpg: directory `/home/jim/.gnupg' created
gpg: new configuration file `/home/jim/.gnupg/gpg.conf' created
gpg: WARNING: options in `/home/jim/.gnupg/gpg.conf' are not yet active during this run
gpg: keyring `/home/jim/.gnupg/pubring.gpg' created
gpg: /home/jim/.gnupg/trustdb.gpg: trustdb created
```
This will try to list available GPG keys on system. The first time it's run, *gpg* will create some directories and files essential to the correct operation and implementation of GnuPG.

Read that post first before coming back here.

# Create key

The very first step of using GnuPG is *creating a key pair*.

Here is what I will do:

1. Choose default key method: (1) RSA and RSA (default).
2. Keysize - the longest - 4096 bits.
3. Key valid for one year
4. Provide name and email address to identify the key.
5. Provide a *passphrase* to protect the private key. The public key don't need protection.
6. Get the key ID: the hex string after the slash of the *pub* output: 12345678.
7. `gpg --list-keys` again to check results.

```bash
jim@laptop ~ $ gpg --gen-key
gpg (GnuPG) 2.0.28; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

gpg: keyring `/home/jim/.gnupg/secring.gpg' created
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 1
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 1y
Key expires at Sun 12 Feb 2017 03:28:59 PM CST
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Jim WU
Email address: email@gmx.com
Comment: Gnus GPG Mail
You selected this USER-ID:
    "Jim WU (Gnus GPG Mail) <email@gmx.com>"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? N
Real name: Jim Wu
You selected this USER-ID:
    "Jim Wu (Gnus GPG Mail) <email@gmx.com>"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.

We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.

gpg: key 12345678 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: next trustdb check due at 2017-02-12
pub   4096R/12345678 2016-02-13 [expires: 2017-02-12]
      Key fingerprint = 0DE8 C833 06AB 8AC2 1980  0013 22B4 40A3 2976 6307
uid       [ultimate] Jim Wu (Gnus GPG Mail) <email@gmx.com>
sub   4096R/87654321 2016-02-13 [expires: 2017-02-12]
```
GnuPG will take several minutes to generate the key pair. You'd better moving the mouse, browsing the web, or having streaming audio in the background will help speed up the process.

# Revocation fallback

Create a revocation certificate fallback. Doing this allow you to revoke the key in case something nasty happens (think of a malicious user gaining control of the key).

```bash
jim@laptop ~ $ gpg --output revoke.asc --gen-revoke 12345678

sec  4096R/12345678 2016-02-13 Jim Wu (Gnus GPG Mail) <email@gmx.com>

Create a revocation certificate for this key? (y/N) y
Please select the reason for the revocation:
  0 = No reason specified
  1 = Key has been compromised
  2 = Key is superseded
  3 = Key is no longer used
  Q = Cancel
(Probably you want to select 1 here)
Your decision? 1
Enter an optional description; end it with an empty line:
> Someone creacked my key and passphrase
> 
Reason for revocation: Key has been compromised
Someone creacked my key and passphrase
Is this okay? (y/N) y

You need a passphrase to unlock the secret key for
user: "Jim Wu (Gnus GPG Mail) <email@gmx.com>"
4096-bit RSA key, ID 12345678, created 2016-02-13

ASCII armored output forced.
Revocation certificate created.

Please move it to a medium which you can hide away; if Mallory gets
access to this certificate he can use it to make your key unusable.
It is smart to print this certificate and store it away, just in case
your media become unreadable.  But have some caution:  The print system of
your machine might store the data and make it available to others!
```
Now the revocation certificate in ASCII armor - revoke.asc - has been created.

# Exporting keys

We have created a key pair and generate a revocation certificate for recovery. Now it's time to distribute the public key - exporting.

```bash
jim@laptop ~ $ gpg --export --armor email@gmx.com
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v2

mQINBFWx9HABEAD6lkezpKbwYhwcsH6RXgmj+l5GVfL8QABb412zRz92Of1SjBR5
ZmAFoC5+9h9lP21TplZgSa1PWMZHl4daBxC8JZhL6zKfnLwcwM8czGXQSfGm8X6w
ZG9dHYruP/wEOZpdTpjanOfWvM/fk5jYJgV2iA4ZOdEZmcj5G6ZdTvgmxWiw9d10
yqQSrEy9b9PM4S+cokLhV0b4v4eIQYDCAokmvQ//SK9k452GYY3VQqHrB2POFu/L
rDSoEwPkKyeknBt8G09iO/zw+3qN9ccZ/oFTcCWQ/qb5iZ7rQ7pQZ/h6z9tb0R/x
HlyRaRGINwSoGI+bQW1TvdJdglXciZh3bPZoSp3PrX2SSaNapb46jxrpRMT+1w40
DAIuQ1WAQWH+qtjwUZVQV/4hsIby/FRGGVwtXUoG3ICf61DnZgVv50QLi5MhqZpR
N3eaIeFdiItuygu2SAmfqMkv3u0jJp89kpeFaYwPErvR9tp5BLOSKQpfU5S0S4Bk
FdIBt7GwiMtgVlnS6jZpefcO1AKooLDNrVLu9/vI7KGjBuG3kQppbqcZOTEfM9D2
TJYKLfa9BNSjgwEk/kJikGmZr3nrqZUUVTiaGufRBrM
EFrDDZebr3DdRhPTOgD40j4YJQ==
=C918
-----END PGP PUBLIC KEY BLOCK-----
```

1. By default, the publick key will be exported on the STDOUT. But out goal is to distribute the public key over the Internet to our friends.

   So usually add `--output name.pub` to export public key to *name.pub* file. It's recommended to distribute this file along with the *fingerprint* of the key. Check `--fingerprint` argument of *gpg*.
2. `armor` tells *gpg* to generate ASCII *text* format output instead of *binary* output.
3. The output actually a certificate of you! Remember famous X.509 certificate? Yeah, you can call *gpg*-exported key *GnuPG certificate*. It not only include your public key string, but others useful information, like key ID, user ID, signatures, fingerprint, sub keys etc. *fingerprint* is usually SHA1 hash. *signature* means the downloaded GnuPG certificate is signed by others (with their private keys).
4. The GnuPG certificate format is different from what usually called X.509 certificate.

# Importing keys

Once you get a copy of the exported public key of your friend, add it to your public keyring - importing.

Pay attention to verify its *fingerprint* in case you get a malicious public key.

1. `gpg --import *friends.pub*`
2. `gpg --edit-key *friends-key*`. *edit-key* prompts for sub-command to do key mangement tasks.
   1. list - list the key information.
   1. fpr - print fingerprint of imported key (same as `gpg --fingerprint`).
   2. sign - sign your friend's public key by your private key.
   3. check - check the signature.
3. After importing the key, you can just it to encrypt message to the key's owner. Or to certify key's owner's signature.

# Echange keys with servers

Both *export* and *import* are to distribute keys around friends you communicate with.

There are many public key servers on the Internet where you can search/upload/download public keys - a public key pool.

All these public key servers will exchange keys periodically. Most of the time, you only need to focus on one single key server. You can specify your desired key server in *~/.gnupg/gpg.conf* or on command line.

```bash
$ gpg --keyserver certserver.pgp.com --recv-key 0xBB7576AC
$ gpg --keyserver certserver.pgp.com --send-key blake@cyb.org
```

If you don't have a copy of receiver's public key when running *gpg*, add `--keyserver` argument to `--sign`, `--encrypt` etc.

# Key Management

1. Key
   1. Your own key pair - public/private key.
   2. Friends'/organizations' public keys. Imported from key file or received from key servers. As noted above, these public keys are actually a certificate.
2. Utility
   1. Public key is distributed over the Internet, i.e. sent to key servers or handed over to friends manually.
      1. People encrypt messages before sending to you.
      2. People certify your signature on documents.
   2. Keep private key confidentially.
      1. Use it to decrypt message received.
      2. Sign documents before publicize.

         A special case is to sign keys. Suppose you have many public keys from friends/key servers. Before using these keys, you should make sure they are *valid* - NOT from MAN-IN-THE-MIDDLE attack or NOT tampered!
2. Validity
   1. Before using a key (own private or others' public), make sure the key is really owned by the one with whom you would communicate. Our own key pair is valid by default. But how about others' public keys? How to validate them?
   2. People actually publicize their *GnuPG certificate* instead of a public key string. When you get his certificate (public key), fingerprint is included. Compare the fingerprint in the certificate with what your friend gave to you. If it's a organization's public certificate, usually fingerprint is pasted on their official page along with public key certificate download link.
   3. After confirmation the public key fingerprint, you *sign* (sub-command of *gpg --edit-key*) the public key with your own private key. To manually sign a key **directly** is to validate a key.
   4. If you don't validate / directly sign a key before encrypting messages to key's owner / certifying key's owner signature, you will receive *gpg* warning like this:

      >gpg: WARNING: This key is not certified with a trusted signature!

      *gpg* detects that the key you are using has not been validated. You can check whether a key is valid by the output of *gpg --list-keys*. If there is an `[unknown]` in front of the user's ID, the key is NOT valid in that you cannot determine if it's owned by the one claiming to own it.
3. Web of trust

   But what if you have got 100 public keys at hand? Sign manually one by one? OMG! GnuPG addresses this problem with a mechanism popularly known as the web of trust. In the web of trust model, responsibility for validating public keys is delegated to people you trust.

   For example, you get public keys: k1, k2, k3, ... You manually / directly signed k1 with your private key and validate it. Meanwhile, k1 signed k2 and k3 directly as well. From the viewpoint of k1, k2 and k3 are valid keys. If you trust k1 fully (level 4, discussed below), then you trust k1's signing action on k2 and k3. You view k2 and k3 as valid as well though you do not sign them directly.

   What does the hell trust mean? **trust means the confidence on someone's capacities at signing/validating/certifying keys**. *trust* is different from *validity*.

   1. Trust is subjective judgement on others' capacity. You trust on somebody according to whether he verifies public fingerprint carefully, whether he is a master of GnuPG and PKI. The purpose of trust is to relieve you from signing/validating keys one by one manually.
   2. Validity is the status of a key from viewpoint of you (your *gpg* on system).
   3. So *trust* serves *validity*. The trust relationship forms a web. *gpg* determines a key's validity by this web of trust.

## Using trust to validate keys

How *trust* works? Recall *gpg --edit-key* above, sub-command *sign* validated public key. There is *trust* sub-command to assign *trust level* to the key.

1. Trust has levels: *unknown none marginal fully ultimate*. Level 0 (unkown) means you don't know the key's owner's capacity at validating keys, while 5 means trust ultimately. Never trust other's key ultimately! *ultimately* trust level is designated for your own key only. Details on trust levels, refer to reference 1.
2. Formerly, a key was considered valid only if you signed it personally.  A more flexible algorithm can now be used: a key K is considered valid if it meets two conditions:
   1. it is signed by enough valid keys, meaning:
      + you have signed it personally,
      + it has been signed by one fully trusted key, or
      + it has been signed by three marginally trusted keys; and
   2. the path of signed keys leading from K back to your own key is five steps or shorter.
   3. *prerequisite*: the parent key should be *fully valid*.

   Apart from the web of trust, there is also a tree of *signing* on which only the first layer nodes of tree is signed by you directly! We cannot determine the validity of a node (key) on lower layers without the help of web of trust.

   On my Gentoo system, there are only a few public keys. I don't care much about web of trust.

## validity level

The *prequisite* in the algorithm: the parent key (signing key) shuld be *fully valid*. Actually, validity also has levels - similar to trust.

You can sign a key directly and check the result. In front of the user ID, you will find `[full]`, means this key is fully valid. For example, you fully trust a marginal valid key k1 on the signing tree and k1 signs another key k2. k2 should NOT be regarded fully valid.

# Sign / encrypt

## sign

```bash
$ gpg --sign message.txt
or
$ gpg --clearsign message.txt
or
$ gpg --detach-sig message.txt
```

1. It uses your private key to sign.
2. The first output is binary format with original file compressed.

   This is NOT a preferred way to sign documents.
3. The 2nd output will append signature to the end of original file without compression.
4. The forth will create a new binary signature file. You can send the original file along with the signature file.

## encrypt

```bash
$ gpg --encrypt --recipient recipient@example.com message.txt
```

1. Should specify who is the receiver by `--recipient`.

## sign and encrypt

```bash
$ gpg --sign --encrypt --recipient recipient@example.com message.txt
```

1. Output is binary format.
2. Cannot use `--clearsign` with `--encrypt` simutaneously.
3. There is no need for `--detach-sig` in this case.

When receving a *secret.gpg* file, you

```bash
$ gpg --output original.txt --decrypt secret.gpg
```

# Agent

Like the SSH Agent, GPG agent cache the private key passphrase. A user don't need to input passphrase each time using the key.

Sometimes working with certain applications requires the use of a GPG key very frequently, which means that a passphrase must be frequently entered. In the past many applications supported a passphrase caching mechanism. This would make life easier for users because passphrases were automatically entered. However, this disallowed sharing this cache across programs (how secure would that be?) and forced applications to reinvent the wheel over and over again.

## pinentry

GnuPG includes *gpg-agent*. Pinentry (*app-crypt/pinentry*) is a helper application that *gpg-agent* uses to request the passphrase in a graphical window. It comes in three flavors: it can popup a window using the GTK+, QT, or curses libraries (depending on the USE flags set in */etc/portage/make.conf*). 

If *app-crypt/pinentry* was installed with more than one popup window type, it is possible to choose between the windows with the eselect pinentry command: 

```bash
laptop ~ # eselect pinentry list
Available pinentry binary implementations:
  [1]   pinentry-gtk-2 *
  [2]   pinentry-curses
laptop ~ # eselect pinentry set 1
```

## configuring gpg-agent

```bash
# ~/.gnupg/gpg-agent.conf
# called when prompt for passphrase the first time
pinentry-program /usr/bin/pinentry-gtk-2
# timeout 30 minutes
default-cache-ttl 1800
```

Now configure GnuPG to use an agent when appropriate. Edit *~/.gnupg/gpg.conf* and add the following line:

```bash
# ~/.gnupg/gpg.conf
#
# DEPRECATED!
use-agent
```

Since GPG2, `use-agent` is deprecated as GPG2 always require *agent*.

## launch agent

An example of launching agent `gpg-agent --sh --daemon --enable-ssh-support --write-env-file /home/jim/.cache/gpg-agent-info`.

## automation

To launch GPG agent automatically on boot, add the command to startup scripts specially for servers (NO X/GUI). Details refer to reference.

On my Gentoo system, Xfce4 also starts the agent for you in /etc/xdg/xfce4/xinitrc in a slightly different way to the above, as long as you don’t already have an agent running. This is perfectly adequate for us as well.

Check by `ps -ef | grep -i gpg-agent`.

## [optional] SSH mode

By default, the gpg-agent doesn’t enable its SSH agent. You have to explicitly enable it yourself, either by passing --enable-ssh-support on the command-line (which we could do by editing the Xsession script) or by `echo enable-ssh-support >> .gnupg/gpg-agent.conf`.

Next time we login and start the gpg-agent, it will enable its SSH mode for us. Great!

## GPG_AGENT_INFO

Like SSH agent, GPG agent exports an environmental variable `GPG_AGENT_INFO`.

## difference

SSH agent support `ssh-add` command to add private keys into agent in advance. GPG agent prompts for passphrase only when decryption.

# Refs

1. [manual](https://www.gnupg.org/gph/en/manual.htm)
1. [gentoo](https://wiki.gentoo.org/wiki/GnuPG#Using_a_GPG_agent)
2. [arch](https://wiki.archlinux.org/index.php/GnuPG)
3. [github](https://github.com/kensanata/ggg)
